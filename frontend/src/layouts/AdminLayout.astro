---
import '../styles/global.css';
import Sidebar from '../components/layout/Sidebar';
import StyleDebugger from '../components/debug/StyleDebugger';

interface Props {
  title: string;
  description?: string;
  currentPath?: string;
  showDebugger?: boolean;
}

const { 
  title, 
  description = 'Plataforma de formularios', 
  currentPath, 
  showDebugger = true 
} = Astro.props;

// Cargar colores desde el servidor durante SSR
let platformColors = {
  primaryColor: '#2563eb',   // Valor por defecto
  secondaryColor: '#1e40af', // Valor por defecto
  accentColor: '#3b82f6'     // Valor por defecto
};

try {
  const API_URL = import.meta.env.PUBLIC_API_URL || 'http://localhost:3000/api';
  const response = await fetch(`${API_URL}/settings/colors`, {
    headers: { 'Cache-Control': 'no-cache' }
  });
  
  if (response.ok) {
    const colors = await response.json();
    platformColors = {
      primaryColor: colors.primaryColor || platformColors.primaryColor,
      secondaryColor: colors.secondaryColor || platformColors.secondaryColor,
      accentColor: colors.accentColor || platformColors.accentColor
    };
    console.log('Colores cargados durante SSR:', platformColors);
  }
} catch (error) {
  console.error('Error al cargar colores durante SSR:', error);
}
---

<!doctype html>
<html lang="es" class="h-full">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width" />
    <meta name="description" content={description} />
    <link rel="icon" type="image/svg+xml" href="/favicon.ico" />
    <title>{title}</title>
    <!-- Aplicar colores cargados durante SSR directamente en el HTML -->  
    <style define:vars={{ primaryColor: platformColors.primaryColor, secondaryColor: platformColors.secondaryColor, accentColor: platformColors.accentColor }}>
      :root {
        --color-primary: var(--primaryColor);
        --color-secondary: var(--secondaryColor);
        --color-accent: var(--accentColor);
      }
    </style>

    <script is:inline define:vars={{ initialColors: platformColors }}>
      // IIFE para aplicar colores inmediatamente
      (function() {
        // Forzar la aplicación de colores directamente en el DOM
        const root = document.documentElement;
        const colors = initialColors;
        
        // Aplicar colores directamente al elemento root
        root.style.setProperty('--color-primary', colors.primaryColor);
        root.style.setProperty('--color-secondary', colors.secondaryColor);
        root.style.setProperty('--color-accent', colors.accentColor);
        
        // Guardar en localStorage para persistencia
        localStorage.setItem('platform_colors', JSON.stringify(colors));
        
        console.log('Colores aplicados directamente:', colors);
        
        // Crear un estilo CSS con !important para forzar los colores
        const forceStyleEl = document.createElement('style');
        forceStyleEl.textContent = `
          :root {
            --color-primary: ${colors.primaryColor} !important;
            --color-secondary: ${colors.secondaryColor} !important;
            --color-accent: ${colors.accentColor} !important;
          }
        `;
        document.head.appendChild(forceStyleEl);
        
        // Verificar colores aplicados
        setTimeout(() => {
          const computedStyle = getComputedStyle(root);
          console.log('Colores verificados:', {
            primary: computedStyle.getPropertyValue('--color-primary').trim(),
            secondary: computedStyle.getPropertyValue('--color-secondary').trim(),
            accent: computedStyle.getPropertyValue('--color-accent').trim()
          });
        }, 100);
        
        // Función para mantener los colores actualizados
        const keepColorsUpdated = () => {
          // Volver a aplicar los colores para asegurar que no se sobrescriban
          root.style.setProperty('--color-primary', colors.primaryColor);
          root.style.setProperty('--color-secondary', colors.secondaryColor);
          root.style.setProperty('--color-accent', colors.accentColor);
        };
        
        // Aplicar colores cada vez que cambie el DOM
        const observer = new MutationObserver(keepColorsUpdated);
        observer.observe(document.documentElement, { 
          childList: true, 
          subtree: true 
        });
        
        // También aplicar colores después de que la página haya cargado completamente
        window.addEventListener('load', keepColorsUpdated);
        
        // Y cada vez que se cargue un recurso
        window.addEventListener('DOMContentLoaded', keepColorsUpdated);
        
        // Actualizar colores desde el servidor periódicamente
        const updateColorsFromServer = async () => {
          try {
            const API_URL = import.meta.env.PUBLIC_API_URL || 'http://localhost:3000/api';
            const response = await fetch(`${API_URL}/settings/colors`, { 
              headers: { 'Cache-Control': 'no-cache' },
              cache: 'no-store'
            });
            
            if (response.ok) {
              const newColors = await response.json();
              
              // Actualizar colores solo si han cambiado
              if (newColors.primaryColor !== colors.primaryColor || 
                  newColors.secondaryColor !== colors.secondaryColor || 
                  newColors.accentColor !== colors.accentColor) {
                
                console.log('Actualizando colores desde el servidor:', newColors);
                
                // Actualizar variables CSS con !important
                forceStyleEl.textContent = `
                  :root {
                    --color-primary: ${newColors.primaryColor} !important;
                    --color-secondary: ${newColors.secondaryColor} !important;
                    --color-accent: ${newColors.accentColor} !important;
                  }
                `;
                
                // También actualizar directamente
                root.style.setProperty('--color-primary', newColors.primaryColor);
                root.style.setProperty('--color-secondary', newColors.secondaryColor);
                root.style.setProperty('--color-accent', newColors.accentColor);
                
                // Actualizar localStorage
                localStorage.setItem('platform_colors', JSON.stringify(newColors));
                
                // Actualizar la referencia local
                Object.assign(colors, newColors);
              }
            }
          } catch (error) {
            console.error('Error al actualizar colores desde el servidor:', error);
          }
        };
        
        // Actualizar colores al cargar la página
        window.addEventListener('load', () => {
          setTimeout(updateColorsFromServer, 500);
        });
        
        // Y cada 30 segundos para mantenerlos sincronizados
        setInterval(updateColorsFromServer, 30000);
      })();
    </script>
  </head>
  <body class="bg-gray-50 h-full">
    <!-- Sidebar -->
    <Sidebar client:load currentPath={currentPath} />
    
    <!-- Main Content -->
    <div class="lg:ml-64 transition-all duration-300 min-h-screen flex flex-col">
      <!-- Top Bar -->
      <header class="bg-white border-b border-gray-200 sticky top-0 z-20">
        <div class="px-4 sm:px-6 lg:px-8 py-4">
          <div class="flex items-center justify-between">
            <div class="lg:hidden w-16"></div> <!-- Spacer for mobile menu button -->
            <h1 class="text-2xl font-bold text-gray-900">{title}</h1>
            <div class="flex items-center gap-4">
              <!-- Aquí puedes agregar notificaciones, búsqueda, etc. -->
            </div>
          </div>
        </div>
      </header>

      <!-- Page Content -->
      <main class="flex-1 p-4 sm:p-6 lg:p-8">
        <slot />
      </main>

      <!-- Footer -->
      <footer class="bg-white border-t border-gray-200 py-6 mt-auto">
        <div class="px-4 sm:px-6 lg:px-8 text-center text-gray-600">
          <p class="text-sm">&copy; 2025 - Plataforma de Formularios</p>
        </div>
      </footer>
    </div>
    
    <!-- Eliminado el depurador de estilos ya que no es necesario con la nueva implementación -->
  </body>
</html>
